# 第一篇

## 第一章：TCP/IP协议族

### 1.1 TCP/IP协议族体系结构以及主要协议

​	TCP/IP协议族是一个四层协议系统，自底而上分别是：数据链路层、网络层、传输层和应用层。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/1.png)

#### 1.1.1 数据链路层

​	数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介上的传输，例如以太网、令牌环。不同的物理网络具有不同的电气特性（例如插口排线的数量），网络驱动程序隐藏了这些细节，为上层提供了统一的接口。

​	常用的协议包括： ARP 和 RARP ，其中ARP全称Address Resolve Protocl，也就是地址解析协议，用来根据IP地址得到MAC物理地址；RARP全称Reverse Address Resolve Rrotocol，也就是逆地址解析协议，用来根据MAC物理地址得到IP地址。

​	网络层使用IP地址寻找一台主机，而数据链路层使用物理地址寻找一台主机。因此需要根据IP地址得到MAC地址，然后才能使用数据链路层提供的服务。RARP协议用于一些无盘工作站，顾名思义，无盘工作站没有存储媒介，无法存储自身的IP地址，于是利用网卡上的物理地址向运行RARP服务的网络管理者查询自身IP，网络管理者拥有该网络上所有机器物理地址到IP地址的映射。

#### 1.1.2 网络层

​	网路层主要负责数据包的选路和转发，广域网（WAN-Wide Area Network）通常使用众多分级的路由器来连接分散的主机或者局域网（LAN-Local Area Network）。通信的两端一般不是直接相连而是经过多个中间节点（路由器）来连接的。网络层的任务是在众多中间节点中选择合适的节点，确定两台主机的通信路径，同时对上层协议隐藏了网络拓扑的细节， 使得在传输层和网络应用层看起来，通信的双方是直接连接的。

​	网路层的一个核心协议是IP协议（因特网协议-Internet Protocol），根据数据包的目的IP地址来决定如何投递它。如果数据包不能直接到达目的主机，那么就为其寻找合适的下一跳，不断地重复这个过程直到到达目标主机或者无法到达目标主机发送失败而被丢弃（上面的过程可以参考快递投递过程）。

​	网络层另一个核心协议是ICMP协议（因特网控制报文协议-Internet Control Message Protocol），主要用于检测网络连接。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/2.png)

​	其中8位类型字段用于区分报文类型，将ICMP协议分为两大类：第一类差错报文，用于回应网络错误，比如目标不可达类型值为3和重定向类型值为5；另一类是查询报文，用来查询网络信息，比如ping程序就是使用ICMP协议查看目标是否可到达类型值为8。有的ICMP报文还使用8位代码字段进一步细分不同的条件，比如重定向报文使用代码值0表示对网络重定向，代码值表示对主机重定向。

​	ICMP协议使用6位校验和字段对整个报文（头部+内容）进行循环冗余校验来检查报文在传输过程中是否损坏。（注：ICMP并非严格意义上的网络层协议，因为它使用IP协议提供的服务，一般来说上层协议使用下层协议提供的服务。）

#### 1.1.3 传输层

​	传输层为两台主机提供端到端（end to end）的通信。与网络层逐跳通信方式不同，传输层只关注通信的起始端和目的端，而不在乎数据包的中转过程。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/3.png)

​	其中，垂直的实线箭头表示TCP/IP协议族各层之间实体通信，虚线表示逻辑通信线路。可见，数据链路层封装了物理网络的电气特性；网络层封装了网络连接的细节；传输层为应用程序封装了端到端的逻辑通信链路，负责数据的收发、链路的超时重传。

​	传输层主要有三个协议：TCP、UDP和SCTP。

​	TCP协议（传输控制协议-Transmission Control Protocol）为应用层提供可靠的、面向连接的和基于流的服务。使用超时重传、数据确认等方式保证数据包被正确的发送到目的端，因此TCP服务是可靠的。使用TCP协议通信双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，例如连接状态、读写缓冲区等。当通信结束时，双方必须关闭连接以释放这些内核数据。TCP服务是基于流的，基于流的数据没有边界限制，源源不断的从通信的一端流入另一端。发送端可以逐个字节的向数据流中写入数据，接收端也可以逐个字节的将它们读出。

​	UDP协议（用户数据包协议-User Datagram Protocol）提供不可靠、无连接和基于数据包的服务。无法保证数据从发送端正确的传递到目的端。数据在中途丢失或数据错误被丢弃只会通知应用程序发送失败。需要自己实现数据确认和超时重传等逻辑。由于通信双方不需要保持连接，因此每次发送数据都需要明确的表名目的端。此外每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将数据一次性读取出来，否则数据会被截断。

​	通过比较上面的两个协议我们可以发现，TCP协议适合对数据完整可靠性高的场景，例如传输邮件、FTP文件传输等，你肯定不希望你收到的邮件中丢失部分重要信息，也不希望接收的文件少了一部分数据。而UDP协议虽然提供不可靠的传输，但是它的优点是速度快，因为不需要建立连接和释放连接的过程，同时，TCP协议提供的是一对一的服务，而UDP可以提供一对一、一对多、多对一的服务。在实时通信、游戏、直播等场景非常合适。

​	SCTP协议（流控制传输协议-Stream Control Transmission Protocol），是一种较新的传输层协议，为了在因特网上传输电话信号而设计的。

#### 1.1.4 应用层

​	应用层负责处理应用程序的逻辑，数据链路层、网络层、传输层负责处理网络通信细节，必须稳定又高效，因此在内核空间实现，而应用层负责处理众多逻辑，在用户空间实现。如果应用层也在内核空间实现会导致内核空间过于臃肿，当然优点是不需要频繁的在用户态和内核态之间进行切换（主要是为了数据的复制）。虽然提高了工作效率，但是实现起来更加复杂，不够灵活也不利于移植。

​	应用层协议有很多，例如ping-检测网络是否可达、telnet-远程登陆协议，在本地完成远程任务、DNS-提供域名到IP地址的转换，OSPF（开放最短路径优先-Open Shortest Path First）-动态路由更新协议，用于路由器之间的通信，告知对方各自的路由信息。

​	应用层协议可以跳过传输层直接使用网络层提供的服务，比如ping和和OSPF。

### 1.2 封装

​	上层协议通过封装使用下层协议提供的服务。应用程序将数据发送到物理网络前，将沿着协议栈从上到下一次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有的包含尾部），以实现该层的功能，这个过程被称为封装。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/4.png)

​	经过TCP封装后的数据报称为TCP报文段，或者简称TCP段。之前提到的TCP协议为通信双方维持一个连接，并在内核中存储相关数据。这部分数据中的头部信息和TCP内核缓冲区数据一起构成了TCP报文段。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/5.png)

​	通过send或者write函数向TCP连接写入数据时，内核中TCP模块先将数据复制到与该连接对应的TCP内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区的数据。

​	经过UDP封装后的数据称为UDP数据报，与TCP不同的是，UDP不需要为应用层数据保存副本。UDP数据报被发送后这个报文就被丢弃了。如果需要重新发送，需要再次将数据从用户态拷贝到内核态的发送缓冲区中。

​	经过IP封装后的数据称为IP数据报，包括头部信息和数据部分，数据部分是一个TCP报文段、UDP报文段或者TCMP报文段。

​	经过数据链路层封装的数据称为帧，传输媒介不同，帧类型也不同。以太网上传输的是以太网帧，令牌环网络上传输的是令牌环帧。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/6.png)

​	上图是以太网帧的封装格式图，6字节的目的物理地址和6字节的源物理地址表示通信双方，4字节CRC字段对帧的其他部分提供循环冗余校验。帧的最大传输单元（Max Transmit Unit,MTU），即帧最多能携带多少上层协议数据，通常收到网络数据类型的限制，以太网帧的MTU是1500字节，如果IP数据报过长，可能会分片。帧才是最终在物理网络上传输的字节序列。

### 1.3 分用

​	当帧到达目的主机时，沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据，从而获取本层信息，经过多层处理后将最后的数据交给应用层，这个过程称为分用。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/7.png)

​	因为IP协议和ARP协议以及RARP协议都使用帧来传输数据，因此帧头部需要提供信息来区分具体使用的哪个协议。以太网帧中使用2字节的类型字段来标识上层协议。例如以太网帧类型字段为0x800-交付IP模块；以太网帧类型字段为0x806-交付ARP模块；以太网帧类型字段为0x835-交付RARP模块。

​	同样由于TCP报文段和UDP报文段都是用IP协议，因此使用6位的协议字段来区分它们。（不使用两位可能是为了以后更好的扩充更多的协议类型。）

​	TCP协议和UDP协议通过头部中的6位端口号字段来区分不同的应用程序。例如DNS对应端口号53，HTTP协议对应端口号80。

​	通过上述步骤，最终将封装前的原始数据送到目标服务。封装是自顶向下，而分用是自底向上。

### 1.4 ARP协议工作原理

​	ARP协议能实现任意网络层地址到任意物理层地址的转换。工作原理是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址，此网络上的其他机器都可以接收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址（发送IP信息得到MAC信息）。

#### 1.4.1 以太网ARP请求/应答报文详解

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/8.png)

- 硬件类型：定义物理地址的类型，代表MAC地址；
- 协议类型：要映射的协议地址类型，0x800代表IP协议；
- 硬件地址长度：MAC地址长度为6；
- 协议地址长度：IPV4协议地址长度为4；IPV6协议地址长度为6；
- 操作：ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）；
- 发送端以太网地址：发送端MAC地址；
- 发送端IP地址：发送端IP地址；
- 目的端以太网地址：目的端MAC地址；
- 目的端IP地址：目的端IP地址；

发送端填充除了目的端以太网地址外的字段，构建ARP发送，而接收方收到后，将自己的以太网地址填充进去后将发送端地址和目的端地址进行交换，然后通过ARP发送。

#### 1.4.2 ARP高速缓存的查看和修改

​	在Linux机器上通过arp或者arp -a来查看本机的所有ARP缓存，sudo arp -d IP地址来删除某个ARP缓存，sudo arp -s IP地址 MAC地址来添加ARP缓存。

​	ARP目的地址如果是FF:FF:FF:FF:FF:FF代表广播地址。

### 1.5 DNS工作原理

​	IP地址难以记忆，因此产生了域名，但是如何主机之间的通信依赖于IP地址，那么就需要一个助手帮助我们完成从域名到IP地址映射的任务，这就是DNS。DNS是一套分布式的的服务系统，每个DNS服务器上都有大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端都使用DNS协议向DNS服务器查询目标主机的IP地址。

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/9.png)

- 16位标识字段用于一对DNS查询和应答，以此区分一个DNS应答是哪个DNS查询的回应；

16位标志字段功能如下：

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/10.png)

- QR：查询还是应答；
- opcode：查询和应答的类型，0-表尊查询；1-反向查询；2-请求服务器状态；
- AA：授权应答标志，仅应答报文使用，1-标识域名服务器是授权服务器；
- TC：截断标志，DNS被截断；
- RD：递归查询标志，1-递归查询；0-迭代查询；
- zero：未使用，都置零；
- rcode：返回码，0-无错误；3-域名不存在

递归查询：A询问B，B告诉AC知道，B问C，C告诉AD知道，A询问D，D返回结果给A；

迭代查询：A询问B，B询问C，C询问D，D将结果返回给C，C返回B，B返回A;

对于查询报文，包含一个查询问题，应答资源记录数、授权资源记录数、额外资源记录数则为0；对于应答报文，应答资源记录数至少为1，授权资源记录数和额外资源记录数可以为0或非0。

查询问题格式：

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11.png)

查询名中封装了主机域名，16位查询类型规定了如何执行查询操作：

- A类，值为1，表示获得目标主机的IP地址；
- 类型为CNAME，值为5，表示获得目标主机别名；
- 类型为PTR，值为12，表示反向查询。

16为查询类通常置为1，表示查询IP地址。

应答格式：

![image-2023220095025565](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/12.png)

- 生存时间代表可被本地客户端程序缓存的时间。

### 1.6 socket和TCP/IP协议族关系

​	数据链路层、网络层、传输层都在内核中实现，因此操作系统需要提供一套系统调用，使得应用程序能够访问这些协议提供的服务。socket就是实现这组系统调用的API（Application Programming Interface）。主要功能如下：

- 将应用程序数据从用户缓冲区复制到TCP/IP内核发送缓冲区，以交付内核来发送数据；从内核TCP/IP接收缓冲区中复制数据到用户缓冲区，以读取数据。
- 应用程序可以通过这组API修改内核中各层协议中的某些头部信息或其他数据结构，从而惊喜的控制底层通信行为。