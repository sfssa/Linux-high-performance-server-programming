# 11.1 socket选项so_rcvtimeo和so_sndtimeo/

网络程序需要处理的第三类事件是定时事件，比如TCP连接中可以定期检测一个客户连接状态。服务器需要做到有效的组织定时事件，使定时事件能够在预期时间被触发并不影响服务器的主要逻辑。通常将定时事件封装陈定时器，使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，实现对定时事件的统一管理。

Linux提供了三种定时方法：

- `socket`选项`SO_RCVTIMEO`和`SO_SNDTIMEO`;
- `SIGALRM`信号；
- I/O复用系统调用的超时参数。

`SO_RCVTIMEO`用来设置socket接收数据超时时间；`SO_SNDTIMEO`用来设置socket发送数据超时时间，因此这两个选项仅对与数据接受和发送相关的socket专用系统调用有效，包括`send/sendmsg/recv/recvmsg/accept/connect`。

![image-20231225101528165](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11_1.png)

# 11.2 sigalrm信号

`alarm`和`setitimer`函数设置的实时闹钟一旦超时，将触发`SIGALRM`信号，因此可以利用该信号的信号处理函数来处理定时任务。但是当需要处理多个定时任务时，需要不断出发`SIGALERM`信号，在其信号处理函数中执行到期的任务，一般而言，`SIGALRM`信号按照固定的频率生成，即由`alarm`或`setitimer`函数设置的定时周期T保持不变，如果某个定时任务的超时时间不是T的整数倍，那么实际执行时间和预期的时间将有一定的偏差。因此定时周期T反映了定时的精度。

1. **"alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号"：**
   - `alarm` 和 `setitimer` 函数可以用来设置实时闹钟，即定时器。
   - 一旦定时器超时，系统会发送 `SIGALRM` 信号。
2. **"当需要处理多个定时任务时，需要不断触发SIGALERM信号，在其信号处理函数中执行到期的任务"：**
   - 如果需要处理多个定时任务，可以在 `SIGALRM` 信号的处理函数中执行相应的任务逻辑。
3. **"SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设置的定时周期T保持不变"：**
   - `SIGALRM` 信号的生成频率是由 `alarm` 或 `setitimer` 函数设置的定时周期 `T` 决定的。
   - 无论 `SIGALRM` 信号是否被处理，它都会在每个周期结束时生成。
4. **"如果某个定时任务的超时时间不是T的整数倍，那么实际执行时间和预期的时间将有一定的偏差"：**
   - 如果某个定时任务的超时时间不是定时周期 `T` 的整数倍，即不是 `T` 的倍数，那么该任务的实际执行时间和预期的时间会有一定的偏差。
   - 这是因为 `SIGALRM` 信号按照固定的周期生成，可能无法精确匹配某个特定时间点。

## 11.2.1 基于升序链表的定时器

定时器通常需要包含两个成员：一个超时时间和一个回调函数，当到达超时时间时执行回调函数。还可能包含回调函数所需要的参数或者是否需要重启定时任务。处理多个定时器时，假设使用链表，还需要额外的指向下一个定时器的指针；双向链表需要两个指针，分别指向前一个定时器和后一个定时器。

## 11.2.2 处理非活动连接

服务器通常需要定期处理非活动连接，从而释放与客户端的连接来获得更多资源为其他客户端提供服务。通常的行为有：给客户端发送重连请求、关闭与客户端的连接。Linux提供了socket中的KEEPALIVE来激活，但会导致对连接的管理更加复杂，因此采用在应用层实现类似于KEEPALIVE的机制，从而管理非活动连接。代码使用SIGALRM信号通过管道来通知主循环执行定时器链表的定时任务-定期关闭非活动连接。

# 11.3 I/O复用系统调用的超时参数

Linux系统性三个I/O复用系统调用都提供了超时参数，不仅能统一处理信号和额I/O事件，也能统一处理定时事件。但是由于I/O复用系统调用可能在超市时间到达前旧返回，因此需要不断更新定时参数来反应剩余的时间。

# 11.4 高性能定时器

## 11.4.1 时间轮

![image-20231225101528165](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11_2.png)

基于排序链表的定时器存在一个问题，添加定时器效率低下，而时间轮解决了这个问题。如上图所示，实线指针指向轮子上的一个槽，以恒定的速度顺时针转动，没转动一步就指向下一个槽，每次转动成为一个滴答`(tick)`，一个滴答的时间称为时间轮的槽间隔`(si)`。时间轮共有N个槽，因此走完一圈的时间是`N*si`，每个槽指向一条定时器链表，每条链表有相同的特征：定时时间相差`N*si`的整数倍，时间轮利用散列表将定时器派发到不同的链表中。假设当前指针指向槽`cs`，要添加一个定时时间为`ti`的定时器，该定时器将被插入到`ts`的链表中：

`ts = (cs + (ti/si))%N`。

基于升序链表的定时器使用唯一的一条链表管理所有的定时器，随着定时器数量的增多，效率会不断降低，而时间轮利用哈希表的思想，将定时器散列到不同的链表上，这样使得每条链表的数量明显少于原来的定时器数目，插入操作的效率基本不受定时器数量的影响。

对于时间轮来说：

- 要提高精度，si的值需要足够小；
- 要提高效率，N值需要足够大。

添加一个时间轮的时间复杂度是O(1)，删除一个定时器的时间复杂度也是O(1)，执行一个定时器的时间复杂度是O(n)，但实际执行一个定时器的效率比O(n)好得多，因为将定时器散列到不同的槽中，等价于散列表入口越多，每条链表的定时器越少。

## 11.4.2 时间堆

设计定时器的另一个思路是：将所有定时器中超市时间最小的一个定时器的超时值作为心搏间隔，这样一旦心搏间隔被调用，超时时间最小的定时器必然到期，可以在tick函数中处理定时任务，然后从剩余的定时器中找出超市时间最小的一个，并将这段最小时间设置为下一次心搏间隔，从而实现了较为精确的定时。最小堆很适合处理这种情况，每个节点的值都雄安与或等于其子节点的值的完全二叉树。

![image-20231225101528165](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11_3.png)

插入值为X的新结点时：

- 创建空穴，如果X可以放到空穴中且不破坏树的结构，插入完成；
- 上滤，交换空穴和父节点；
- 直到X可以插入到空穴。

![image-20231225101528165](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11_4.png)

最小堆的删除：

- 在根节点创建空穴，由于少了一个元素，可以把堆的最后一个元素X移动到该堆的某个地方，如果X可以放入空穴，删除完成；
- 执行下滤，交换空穴和两个子节点中值较小的元素，直到X可以放入空穴。

![image-20231225101528165](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11_5.png)

由于最小堆是一种完全二叉树，可以用数组组织其中元素，对于数组中任意一个位置i上的元素，其左儿子结点在位置2I+1上，其右儿子在位置2i+2上，父节点在位置[(i-1)/2]上（i > 0），与链表相比，数组不仅节省空间，而且更容易实现堆的插入、删除等操作。

![image-20231225101528165](https://github.com/sfssa/Linux-high-performance-server-programming/blob/master/static/11_6.png)

将一个数组初始化最小堆：

- 初始化一个空堆，将数组中元素插入到该堆中（效率低），实际只需要对数组中的第[（N-1）/2 ]~0个元素执行下滤操作，即可保证该数组构成一个最小堆，因为包含N个元素的完全二叉树而言，具有[(N-1)/2]个非叶子结点，这些非叶子节点正是该完全二叉树的第0~[(N-1)/2]个节点，只需要保证这些非叶子节点的子树具有堆序性质，整个树就具有堆序性质。

对于时间堆来说，添加一个定时器的时间复杂度是O(lgn)，删除一个定时器的时间复杂度是O(1)，执行一个定时器的时间复杂度是O(1)，因此时间堆的效率是很高的。